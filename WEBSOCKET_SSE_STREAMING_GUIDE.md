\n# üåê WebSocket & SSE Streaming Infrastructure - Yellow Box Real-Time Communication\n\n## üìã **Current Status**\n- ‚úÖ MCP server architecture designed ([`YELLOWBOX_MCP_SERVER_INTEGRATION_ARCHITECTURE.md`](YELLOWBOX_MCP_SERVER_INTEGRATION_ARCHITECTURE.md:1))\n- ‚úÖ Integration preparation ready ([`mcp-server-integration-prep.ts`](mcp-server-integration-prep.ts:1))\n- ‚è≥ **NEXT STEP**: Deploy streaming infrastructure\n\n## üéØ **4. WebSocket and SSE Streaming Infrastructure**\n\n### **Architecture Overview**\n```\nWeb App ‚Üê‚Üí WebSocket Server ‚Üê‚Üí Event Router ‚Üê‚Üí Firebase\n       ‚Üê‚Üí SSE Endpoints    ‚Üê‚Üí Message Queue ‚Üê‚Üí N8N\n```\n\n### **A. WebSocket Server Implementation**\n\n#### Core WebSocket Service\n```typescript\n// mcp-server/src/services/websocket.ts\nimport { Server as SocketIOServer } from 'socket.io';\nimport { Server as HttpServer } from 'http';\nimport { verifyFirebaseToken } from './firebase';\n\nexport class WebSocketService {\n  private io: SocketIOServer;\n  private connectedUsers = new Map<string, any>();\n\n  constructor(httpServer: HttpServer) {\n    this.io = new SocketIOServer(httpServer, {\n      cors: {\n        origin: [\"http://localhost:8080\", \"https://yellowbox-8e0e6.web.app\"],\n        credentials: true\n      },\n      transports: ['websocket', 'polling']\n    });\n\n    this.setupAuthentication();\n    this.setupEventHandlers();\n  }\n\n  private setupAuthentication() {\n    this.io.use(async (socket, next) => {\n      try {\n        const token = socket.handshake.auth.token;\n        const decodedToken = await verifyFirebaseToken(token);\n        \n        socket.userId = decodedToken.uid;\n        socket.userRole = decodedToken.role || 'rider';\n        \n        next();\n      } catch (error) {\n        next(new Error('Authentication failed'));\n      }\n    });\n  }\n\n  private setupEventHandlers() {\n    this.io.on('connection', (socket) => {\n      console.log(`User connected: ${socket.userId} (${socket.userRole})`);\n      \n      // Store connection\n      this.connectedUsers.set(socket.userId, {\n        socket,\n        role: socket.userRole,\n        connectedAt: new Date()\n      });\n\n      // Role-based room joining\n      socket.join(`role_${socket.userRole}`);\n      \n      // Event subscriptions\n      socket.on('subscribe_rider_locations', () => {\n        if (['admin', 'operations'].includes(socket.userRole)) {\n          socket.join('rider_locations');\n        }\n      });\n\n      socket.on('subscribe_expense_updates', () => {\n        if (['admin', 'finance', 'operations'].includes(socket.userRole)) {\n          socket.join('expense_updates');\n        }\n      });\n\n      socket.on('publish_location', (locationData) => {\n        if (socket.userRole === 'rider') {\n          this.broadcastRiderLocation(socket.userId, locationData);\n        }\n      });\n\n      socket.on('disconnect', () => {\n        console.log(`User disconnected: ${socket.userId}`);\n        this.connectedUsers.delete(socket.userId);\n      });\n    });\n  }\n\n  // Broadcast rider location to subscribers\n  broadcastRiderLocation(riderId: string, locationData: any) {\n    const enrichedData = {\n      riderId,\n      ...locationData,\n      timestamp: new Date().toISOString()\n    };\n\n    this.io.to('rider_locations').emit('rider_location_update', enrichedData);\n  }\n\n  // Broadcast expense status changes\n  broadcastExpenseUpdate(expenseData: any) {\n    this.io.to('expense_updates').emit('expense_status_change', expenseData);\n  }\n\n  // Send targeted notifications\n  sendToUser(userId: string, event: string, data: any) {\n    const userConnection = this.connectedUsers.get(userId);\n    if (userConnection) {\n      userConnection.socket.emit(event, data);\n    }\n  }\n\n  // Send to role-based groups\n  sendToRole(role: string, event: string, data: any) {\n    this.io.to(`role_${role}`).emit(event, data);\n  }\n}\n```\n\n### **B. Server-Sent Events (SSE) Implementation**\n\n#### SSE Service for Live Dashboard\n```typescript\n// mcp-server/src/services/sse.ts\nimport { Request, Response } from 'express';\nimport { EventEmitter } from 'events';\n\nexport class SSEService extends EventEmitter {\n  private connections = new Map<string, Response>();\n\n  // Dashboard metrics stream\n  handleDashboardStream(req: Request, res: Response) {\n    const userId = req.query.userId as string;\n    \n    // Setup SSE headers\n    res.writeHead(200, {\n      'Content-Type': 'text/event-stream',\n      'Cache-Control': 'no-cache',\n      'Connection': 'keep-alive',\n      'Access-Control-Allow-Origin': '*',\n      'Access-Control-Allow-Headers': 'Cache-Control'\n    });\n\n    // Store connection\n    this.connections.set(userId, res);\n\n    // Send initial data\n    this.sendSSEData(res, 'dashboard_metrics', {\n      activeRiders: 12,\n      pendingExpenses: 5,\n      totalRevenue: 45000,\n      timestamp: new Date().toISOString()\n    });\n\n    // Heartbeat to keep connection alive\n    const heartbeat = setInterval(() => {\n      this.sendSSEData(res, 'heartbeat', { timestamp: new Date().toISOString() });\n    }, 30000);\n\n    // Cleanup on disconnect\n    req.on('close', () => {\n      clearInterval(heartbeat);\n      this.connections.delete(userId);\n    });\n  }\n\n  // Fleet tracking stream\n  handleFleetStream(req: Request, res: Response) {\n    const userId = req.query.userId as string;\n    \n    res.writeHead(200, {\n      'Content-Type': 'text/event-stream',\n      'Cache-Control': 'no-cache',\n      'Connection': 'keep-alive'\n    });\n\n    this.connections.set(`fleet_${userId}`, res);\n\n    // Send initial fleet data\n    this.sendSSEData(res, 'fleet_update', {\n      riders: [],\n      geofences: [],\n      alerts: []\n    });\n  }\n\n  // Alert stream\n  handleAlertStream(req: Request, res: Response) {\n    const userId = req.query.userId as string;\n    \n    res.writeHead(200, {\n      'Content-Type': 'text/event-stream',\n      'Cache-Control': 'no-cache',\n      'Connection': 'keep-alive'\n    });\n\n    this.connections.set(`alerts_${userId}`, res);\n  }\n\n  // Send data via SSE\n  private sendSSEData(res: Response, event: string, data: any) {\n    res.write(`event: ${event}\\n`);\n    res.write(`data: ${JSON.stringify(data)}\\n\\n`);\n  }\n\n  // Broadcast to all dashboard connections\n  broadcastDashboardUpdate(data: any) {\n    this.connections.forEach((res, connectionId) => {\n      if (connectionId.startsWith('dashboard_')) {\n        this.sendSSEData(res, 'dashboard_update', data);\n      }\n    });\n  }\n\n  // Broadcast fleet updates\n  broadcastFleetUpdate(data: any) {\n    this.connections.forEach((res, connectionId) => {\n      if (connectionId.startsWith('fleet_')) {\n        this.sendSSEData(res, 'fleet_update', data);\n      }\n    });\n  }\n}\n```\n\n### **C. Web App Integration**\n\n#### WebSocket Client Service\n```typescript\n// yellowboxdxb-main/src/services/mcpWebSocketService.ts\nimport { io, Socket } from 'socket.io-client';\nimport { auth } from '../config/firebase';\n\nexport class MCPWebSocketService {\n  private socket: Socket | null = null;\n  private reconnectAttempts = 0;\n  private maxReconnectAttempts = 5;\n  private subscriptions = new Map<string, Function>();\n\n  async connect() {\n    const user = auth.currentUser;\n    if (!user) throw new Error('User not authenticated');\n\n    const token = await user.getIdToken();\n    \n    this.socket = io('ws://localhost:3001', {\n      auth: { token },\n      transports: ['websocket', 'polling']\n    });\n\n    this.socket.on('connect', () => 