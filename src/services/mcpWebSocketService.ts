\n/**\n * MCP WebSocket Service for Real-time Fleet Management\n * Handles bidirectional communication with MCP server\n */\n\nimport { EventEmitter } from 'events';\nimport { RiderLocation, ExpenseUpdate, DocumentUpdate, BikeUpdate, FleetAlert } from '../types/mcp';\n\nexport interface WebSocketMessage {\n  type: 'auth' | 'subscribe' | 'unsubscribe' | 'event' | 'heartbeat' | 'error';\n  id?: string;\n  token?: string;\n  userId?: string;\n  role?: string;\n  eventTypes?: string[];\n  filters?: Record<string, any>;\n  payload?: any;\n  error?: {\n    code: number;\n    message: string;\n  };\n}\n\nexport interface EventCallback<T = any> {\n  (data: T): void;\n}\n\nexport interface OutgoingEvent {\n  type: string;\n  payload: any;\n  priority?: 'low' | 'medium' | 'high' | 'critical';\n}\n\nexport class MCPWebSocketService extends EventEmitter {\n  private ws: WebSocket | null = null;\n  private reconnectAttempts = 0;\n  private maxReconnectAttempts = 5;\n  private reconnectDelay = 2000;\n  private heartbeatInterval: NodeJS.Timeout | null = null;\n  private subscriptions: Map<string, EventCallback> = new Map();\n  private isConnected = false;\n  private userId: string | null = null;\n  private userRole: string | null = null;\n  private authToken: string | null = null;\n\n  constructor(private wsUrl: string = 'ws://localhost:3001/ws') {\n    super();\n  }\n\n  /**\n   * Connect to MCP WebSocket server\n   */\n  async connect(userId: string, userRole: string, authToken: string): Promise<void> {\n    this.userId = userId;\n    this.userRole = userRole;\n    this.authToken = authToken;\n\n    return new Promise((resolve, reject) => {\n      try {\n        this.ws = new WebSocket(this.wsUrl);\n\n        this.ws.onopen = () => {\n          console.log('üîó Connected to MCP WebSocket server');\n          this.isConnected = true;\n          this.reconnectAttempts = 0;\n          this.authenticate();\n          this.startHeartbeat();\n          this.emit('connected');\n          resolve();\n        };\n\n        this.ws.onmessage = (event) => {\n          this.handleMessage(event.data);\n        };\n\n        this.ws.onclose = (event) => {\n          console.log('üîå MCP WebSocket connection closed', event.code, event.reason);\n          this.isConnected = false;\n          this.cleanup();\n          this.emit('disconnected');\n          \n          if (!event.wasClean && this.reconnectAttempts < this.maxReconnectAttempts) {\n            this.scheduleReconnect();\n          }\n        };\n\n        this.ws.onerror = (error) => {\n          console.error('‚ùå MCP WebSocket error:', error);\n          this.emit('error', error);\n          reject(error);\n        };\n\n      } catch (error) {\n        console.error('‚ùå Failed to create WebSocket connection:', error);\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Disconnect from MCP WebSocket server\n   */\n  disconnect(): void {\n    if (this.ws) {\n      this.ws.close(1000, 'Client disconnect');\n    }\n    this.cleanup();\n  }\n\n  /**\n   * Subscribe to specific event types\n   */\n  subscribe(eventType: string, callback: EventCallback, filters?: Record<string, any>): string {\n    const subscriptionId = `${eventType}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    this.subscriptions.set(subscriptionId, callback);\n\n    if (this.isConnected) {\n      this.sendMessage({\n        type: 'subscribe',\n        id: subscriptionId,\n        eventTypes: [eventType],\n        filters\n      });\n    }\n\n    return subscriptionId;\n  }\n\n  /**\n   * Unsubscribe from event\n   */\n  unsubscribe(subscriptionId: string): void {\n    this.subscriptions.delete(subscriptionId);\n\n    if (this.isConnected) {\n      this.sendMessage({\n        type: 'unsubscribe',\n        id: subscriptionId\n      });\n    }\n  }\n\n  /**\n   * Send event to MCP server\n   */\n  async send(event: OutgoingEvent): Promise<void> {\n    if (!this.isConnected) {\n      throw new Error('WebSocket not connected');\n    }\n\n    this.sendMessage({\n      type: 'event',\n      payload: {\n        ...event,\n        userId: this.userId,\n        timestamp: new Date().toISOString()\n      }\n    });\n  }\n\n  /**\n   * Real-time event handlers for fleet management\n   */\n\n  onRiderLocationUpdate(callback: (location: RiderLocation) => void): string {\n    return this.subscribe('rider_location', callback);\n  }\n\n  onExpenseStatusChange(callback: (expense: ExpenseUpdate) => void): string {\n    return this.subscribe('expense_update', callback);\n  }\n\n  onDocumentVerification(callback: (document: DocumentUpdate) => void): string {\n    return this.subscribe('document_update', callback);\n  }\n\n  onBikeStatusChange(callback: (bike: BikeUpdate) => void): string {\n    return this.subscribe('bike_update', callback);\n  }\n\n  onFleetAlert(callback: (alert: FleetAlert) => void): string {\n    return this.subscribe('fleet_alert', callback);\n  }\n\n  onSystemAlert(callback: (alert: any) => void): string {\n    return this.subscribe('system_alert', callback);\n  }\n\n  /**\n   * Role-specific subscriptions\n   */\n\n  subscribeToAdminEvents(): string[] {\n    const subscriptions: string[] = [];\n    \n    subscriptions.push(this.onRiderLocationUpdate((location) => {\n      this.emit('rider_location', location);\n    }));\n    \n    subscriptions.push(this.onExpenseStatusChange((expense) => {\n      this.emit('expense_update', expense);\n    }));\n    \n    subscriptions.push(this.onDocumentVerification((document) => {\n      this.emit('document_update', document);\n    }));\n    \n    subscriptions.push(this.onBikeStatusChange((bike) => {\n      this.emit('bike_update', bike);\n    }));\n    \n    subscriptions.push(this.onFleetAlert((alert) => {\n      this.emit('fleet_alert', alert);\n    }));\n    \n    subscriptions.push(this.onSystemAlert((alert) => {\n      this.emit('system_alert', alert);\n    }));\n\n    return subscriptions;\n  }\n\n  subscribeToRiderEvents(riderId: string): string[] {\n    const subscriptions: string[] = [];\n    \n    subscriptions.push(this.subscribe('expense_update', (expense: ExpenseUpdate) => {\n      if (expense.riderId === riderId) {\n        this.emit('my_expense_update', expense);\n      }\n    }, { riderId }));\n    \n    subscriptions.push(this.subscribe('document_update', (document: DocumentUpdate) => {\n      if (document.riderId === riderId) {\n        this.emit('my_document_update', document);\n      }\n    }, { riderId }));\n    \n    subscriptions.push(this.subscribe('bike_update', (bike: BikeUpdate) => {\n      if (bike.riderId === riderId) {\n        this.emit('my_bike_update', bike);\n      }\n    }, { riderId }));\n\n    return subscriptions;\n  }\n\n  subscribeToFinanceEvents(): string[] {\n    const subscriptions: string[] = [];\n    \n    subscriptions.push(this.onExpenseStatusChange((expense) => {\n      this.emit('expense_update', expense);\n    }));\n    \n    subscriptions.push(this.subscribe('budget_alert', (alert) => {\n      this.emit('budget_alert', alert);\n    }));\n\n    return subscriptions;\n  }\n\n  subscribeToOperationsEvents(): string[] {\n    const subscriptions: string[] = [];\n    \n    subscriptions.push(this.onRiderLocationUpdate((location) => {\n      this.emit('rider_location', location);\n    }));\n    \n    subscriptions.push(this.onDocumentVerification((document) => {\n      this.emit('document_update', document);\n    }));\n    \n    subscriptions.push(this.onBikeStatusChange((bike) => {\n      this.emit('bike_update', bike);\n    }));\n    \n    subscriptions.push(this.onFleetAlert((alert) => {\n     